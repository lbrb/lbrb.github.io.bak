<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>梁彬的博客</title>
    <link>lbrb.github.io</link>
    <description>梁彬的博客</description>
    
      <item>
        <title>Mysql Index</title>
        <link>lbrb.github.io/2015/01/12/mysql-index.html</link>
        <guid isPermaLink="true">lbrb.github.io/2015/01/12/mysql-index.html</guid>
        <pubDate>Mon, 12 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;###索引概述&lt;/p&gt;

&lt;p&gt;所有MySQL列类型可以被索引。对相关列使用索引是提高SELECT操作性能的最佳途径。根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的限制。&lt;/p&gt;

&lt;p&gt;在MySQL 5.1中，对于MyISAM和InnoDB表，前缀可以达到1000字节长。请注意前缀的限制应以字节为单位进行测量，而CREATE TABLE语句中的前缀长度解释为字符数。当为使用多字节字符集的列指定前缀长度时一定要加以考虑。&lt;/p&gt;

&lt;p&gt;还可以创建FULLTEXT索引。该索引可以用于全文搜索。只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列。索引总是对整个列进行，不支持局部(前缀)索引。也可以为空间列类型创建索引。只有MyISAM存储引擎支持空间类型。空间索引使用R-树。默认情况MEMORY(HEAP)存储引擎使用hash索引，但也支持B-树索引。&lt;/p&gt;

&lt;p&gt;###设计索引的原则&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;搜索的索引列，不一定是所要选择的列&lt;br /&gt;
换句话说，最适合索引的列是出现在WHERE 子句中的列，或连接子句中指定的列，而不是出现在SELECT 关键字后的选择列表中的列。&lt;/li&gt;
  &lt;li&gt;使用惟一索引&lt;br /&gt;
考虑某列中值的分布。对于惟一值的列，索引的效果最好，而具有多个重复值的列，其索引效果最差。例如，存放年龄的列具有不同值，很容易区分 各行。而用来记录性别的列，只含有“ M”和“F”，则对此列进行索引没有多大用处（不管搜索哪个值，都会得出大约一半的行）。&lt;/li&gt;
  &lt;li&gt;使用短索引&lt;br /&gt;
如果对串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，如果有一个CHAR(200) 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前10 个或20 个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘I/O 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL也可以在内存中容纳更多的值。这增加 了找到行而不用读取索引中较多块的可能性。（当然，应该利用一些常识。如仅用列值的第一个字符进行索引是不可能有多大好处的，因为这个索引中不会有许多不 同的值。）&lt;/li&gt;
  &lt;li&gt;利用最左前缀&lt;br /&gt;
在创建一个n 列的索引时，实际是创建了MySQL可利用的n 个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。（这与索引一个列的前缀不同，索引一个列的前缀是利用该的前n 个字符作为索引值。）&lt;/li&gt;
  &lt;li&gt;不要过度索引&lt;br /&gt;
不要以为索引“越多越好”，什么东西都用索引是错的。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能，这一点我们前面已经介绍 过。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所花的时间越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表 的修改速度。此外，MySQL在生成一个执行计划时，要考虑各个索引，这也要费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL选择不到所要使用的最好索引。只保持所需的索引有利于查询优化。如果想给已索引的表增加索引，应该考虑所要增加的索引是否是现有多列索引的最左 索引。如果是，则就不要费力去增加这个索引了，因为已经有了。&lt;/li&gt;
  &lt;li&gt;考虑在列上进行的比较类型&lt;br /&gt;
索引可用于“ &amp;lt;”、“ &amp;lt; = ”、“ = ”、“ &amp;gt; =”、“ &amp;gt; ”和BETWEEN 运算。在模式具有一个直接量前缀时，索引也用于LIKE 运算。如果只将某个列用于其他类型的运算时（如STRCMP( )），对其进行索引没有价值。&lt;br /&gt;
###Mysql如何使用索引&lt;br /&gt;
索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，MySQL能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。如果一个表有1000行，这比顺序读取至少快100倍。注意如果你需要访问大部分行，顺序读取要快得多，因为此时我们避免磁盘搜索。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大多数MySQL索引(PRIMARY KEY、UNIQUE、INDEX和FULLTEXT)在B树中存储。只是空间列类型的索引使用R-树，并且MEMORY表还支持hash索引。&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Jquery queue</title>
        <link>lbrb.github.io/2015/01/11/jquery-queue.html</link>
        <guid isPermaLink="true">lbrb.github.io/2015/01/11/jquery-queue.html</guid>
        <pubDate>Sun, 11 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;h3. 利用Jquery的queue完成复杂的动画效果&lt;/p&gt;

&lt;p&gt;简单的动画效果我们可以使用下面的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;#object&#39;).hide(&#39;slow&#39;).show(&#39;slow&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是复杂的动画效果，比如多个元素多种类型的效果，用上面的方法就很难实现了，这里使用queue来实现复杂的动画效果。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(&#39;document&#39;).queue([fun1, fun2, fun3]);//fun1,fun2,fun3为方法，里面可以写任何代码，动画或增删改元素都可以
function fun1(){
    $(&quot;#a&quot;).hide(&#39;slow&#39;, function(){$(&#39;document&#39;).dequeue();})//方法执行完毕后，执行队列中的下一个方法。
}
...//定义需要执行的方法
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/hh54188/archive/2011/04/09/1996469.html&quot;&gt;jQuery动画高级用法&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Ubuntu14 添加系统监控</title>
        <link>lbrb.github.io/2015/01/11/indicator-sysmonitor.html</link>
        <guid isPermaLink="true">lbrb.github.io/2015/01/11/indicator-sysmonitor.html</guid>
        <pubDate>Sun, 11 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;h3. Ubuntu14 利用indicator-sysmonitor在标题栏显示网速，cpu, 内存等信息&lt;/p&gt;

&lt;p&gt;具体步骤&lt;/p&gt;

&lt;p&gt;*下载包&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget -c https://launchpad.net/indicator-sysmonitor/trunk/4.0/+download/indicator-sysmonitor_0.4.3_all.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*安装依赖&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install python python-psutil python-appindicator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dpkg -i indicator-sysmonitor_0.4.3_all.deb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*由于默认的图标在ubuntu中找不到，所以要更改图标。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo vim /usr/bin/indicator-sysmonitor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将 724 行的 sysmonitor 改为刚才记下的 application-community&lt;/p&gt;

&lt;p&gt;*执行终端&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;indicator-sysmonitor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*开机启动&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir ~/.config/autostart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，鼠标右键点击标题栏上 application-community 红心图标，弹出菜单，选择首选项，选中Run on startup。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>MySQL常用资源</title>
        <link>lbrb.github.io/2014/05/11/general-mysql-resources.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/05/11/general-mysql-resources.html</guid>
        <pubDate>Sun, 11 May 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;常用命令&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;登录数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mysql -h localhost -uroot -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;导出数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mysqldump -uroot -p db &amp;gt; db.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;导入数据库&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mysql -uroot -p db &amp;lt; db.sql
// or
mysql -uroot -p db -e &quot;source /path/to/db.sql&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;开启远程登录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;grant all privileges on ss.* to &#39;root&#39;@&#39;%&#39; indentified by &#39;passoword&#39; with grant option;
// or 
update user set Host=&quot;%&quot; and User=&quot;root&quot;
// 注意%是不包含localhost的
flush privileges;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;创建用户&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE USER &#39;test&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;创建表&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;CREATE SCHEMA testdb DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;赋予数据库权限&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;GRANT ALL ON testdb.* TO &#39;test&#39;@&#39;localhost&#39;;
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>MySQL大量数据插入各种方法性能分析与比较</title>
        <link>lbrb.github.io/2014/04/16/insert-large-number-of-data-in-mysql.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/04/16/insert-large-number-of-data-in-mysql.html</guid>
        <pubDate>Wed, 16 Apr 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;不管是日常业务数据处理中，还是数据库的导入导出，都可能遇到需要处理大量数据的插入。插入的方式和数据库引擎都会对插入速度造成影响，这篇文章旨在从理论和实践上对各种方法进行分析和比较，方便以后应用中插入方法的选择。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;插入分析&lt;/h2&gt;
&lt;p&gt;MySQL中插入一个记录需要的时间由下列因素组成，其中的数字表示大约比例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;连接：（3）&lt;/li&gt;
  &lt;li&gt;发送查询给服务器：（2）&lt;/li&gt;
  &lt;li&gt;分析查询：（2）&lt;/li&gt;
  &lt;li&gt;插入记录：（1x记录大小）&lt;/li&gt;
  &lt;li&gt;插入索引：（1x索引）&lt;/li&gt;
  &lt;li&gt;关闭：（1）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果我们每插入一条都执行一个SQL语句，那么我们需要执行除了连接和关闭之外的所有步骤N次，这样是非常耗时的，优化的方式有一下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在每个insert语句中写入多行，批量插入&lt;/li&gt;
  &lt;li&gt;将所有查询语句写入事务中&lt;/li&gt;
  &lt;li&gt;利用Load Data导入数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每种方式执行的性能如下。&lt;/p&gt;

&lt;h2 id=&quot;innodb&quot;&gt;Innodb引擎&lt;/h2&gt;
&lt;p&gt;InnoDB 给 MySQL 提供了具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。InnoDB 提供了行锁(locking on row level)以及外键约束(FOREIGN KEY constraints)。&lt;/p&gt;

&lt;p&gt;InnoDB 的设计目标是处理大容量数据库系统，它的 CPU 利用率是其它基于磁盘的关系数据库引擎所不能比的。在技术上，InnoDB 是一套放在 MySQL 后台的完整数据库系统，InnoDB 在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;测试环境&lt;/h3&gt;
&lt;p&gt;Macbook Air 12mid apache2.2.26 php5.5.10 mysql5.6.16&lt;/p&gt;

&lt;p&gt;总数100W条数据&lt;/p&gt;

&lt;p&gt;插入完后数据库大小38.6MB（无索引），46.8（有索引）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无索引单条插入 总耗时：229s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;有索引单条插入 总耗时：242s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;无索引批量插入 总耗时：10s 峰值内存：8643KB&lt;/li&gt;
  &lt;li&gt;有索引批量插入 总耗时：16s 峰值内存：8643KB&lt;/li&gt;
  &lt;li&gt;无索引事务插入 总耗时：78s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;有索引事务插入 总耗时：82s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;无索引Load Data插入 总耗时：12s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;有索引Load Data插入 总耗时：11s 峰值内存：246KB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;myiasm&quot;&gt;MyIASM引擎&lt;/h2&gt;
&lt;p&gt;MyISAM 是MySQL缺省存贮引擎。设计简单，支持全文搜索。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;测试环境&lt;/h3&gt;
&lt;p&gt;Macbook Air 12mid apache2.2.26 php5.5.10 mysql5.6.16&lt;/p&gt;

&lt;p&gt;总数100W条数据&lt;/p&gt;

&lt;p&gt;插入完后数据库大小19.1MB（无索引），38.6（有索引）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;无索引单条插入 总耗时：82s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;有索引单条插入 总耗时：86s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;无索引批量插入 总耗时：3s 峰值内存：8643KB&lt;/li&gt;
  &lt;li&gt;有索引批量插入 总耗时：7s 峰值内存：8643KB&lt;/li&gt;
  &lt;li&gt;无索引Load Data插入 总耗时：6s 峰值内存：246KB&lt;/li&gt;
  &lt;li&gt;有索引Load Data插入 总耗时：8s 峰值内存：246KB&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我测试的数据量不是很大，不过可以大概了解这几种插入方式对于速度的影响，最快的必然是Load Data方式。这种方式相对比较麻烦，因为涉及到了写文件，但是可以兼顾内存和速度。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;测试代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
$dsn = &#39;mysql:host=localhost;dbname=test&#39;;
$db = new PDO($dsn,&#39;root&#39;,&#39;&#39;,array(PDO::ATTR_PERSISTENT =&amp;gt; true));
//删除上次的插入数据
$db-&amp;gt;query(&#39;delete from `test`&#39;);
//开始计时
$start_time = time();
$sum = 1000000;
// 测试选项
$num = 1;

if ($num == 1){
    // 单条插入
    for($i = 0; $i &amp;lt; $sum; $i++){
        $db-&amp;gt;query(&quot;insert into `test` (`id`,`name`) values ($i,&#39;tsetssdf&#39;)&quot;);
    }
} elseif ($num == 2) {
    // 批量插入，为了不超过max_allowed_packet，选择每10万插入一次
    for ($i = 0; $i &amp;lt; $sum; $i++) {
        if ($i == $sum - 1) { //最后一次
            if ($i%100000 == 0){
                $values = &quot;($i, &#39;testtest&#39;)&quot;;
                $db-&amp;gt;query(&quot;insert into `test` (`id`, `name`) values $values&quot;);
            } else {
                $values .= &quot;,($i, &#39;testtest&#39;)&quot;;
                $db-&amp;gt;query(&quot;insert into `test` (`id`, `name`) values $values&quot;);
            }
            break;
        }
        if ($i%100000 == 0) { //平常只有在这个情况下才插入
            if ($i == 0){
                $values = &quot;($i, &#39;testtest&#39;)&quot;;
            } else {
                $db-&amp;gt;query(&quot;insert into `test` (`id`, `name`) values $values&quot;);
                $values = &quot;($i, &#39;testtest&#39;)&quot;;
            }
        } else {
            $values .= &quot;,($i, &#39;testtest&#39;)&quot;;    
        }
    }
} elseif ($num == 3) {
    // 事务插入
    $db-&amp;gt;beginTransaction(); 
    for($i = 0; $i &amp;lt; $sum; $i++){
        $db-&amp;gt;query(&quot;insert into `test` (`id`,`name`) values ($i,&#39;tsetssdf&#39;)&quot;);
    }
    $db-&amp;gt;commit();
} elseif ($num == 4) {
    // 文件load data
    $filename = dirname(__FILE__).&#39;/test.sql&#39;;
    $fp = fopen($filename, &#39;w&#39;);
    for($i = 0; $i &amp;lt; $sum; $i++){
        fputs($fp, &quot;$i,&#39;testtest&#39;\r\n&quot;);    
    }
    $db-&amp;gt;exec(&quot;load data infile &#39;$filename&#39; into table test fields terminated by &#39;,&#39;&quot;);
}

$end_time = time();
echo &quot;总耗时&quot;, ($end_time - $start_time), &quot;秒\n&quot;;
echo &quot;峰值内存&quot;, round(memory_get_peak_usage()/1000), &quot;KB\n&quot;;

?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://coolshell.cn/articles/652.html&quot;&gt;MySQL: InnoDB 还是 MyISAM?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ixdba.net/article/2f/2092.html&quot;&gt;mysql存储引擎：InnoDB和MyISAM的区别与优劣&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.uml.org.cn/sjjm/201108293.asp&quot;&gt;MySQL大数据量快速插入方法和语句优化&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>我们得比自己更努力</title>
        <link>lbrb.github.io/2014/04/15/we-should-be-better-than-us.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/04/15/we-should-be-better-than-us.html</guid>
        <pubDate>Tue, 15 Apr 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;选择了与众不同，就要准备好面对自己选择的道路的曲折，以及周围人们的不解。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们的家庭乃至这个社会，都已经为我们设计好了一条道路。&lt;/p&gt;

&lt;p&gt;如果你听从父母的建议，或者接受社会舆论的引导，&lt;/p&gt;

&lt;p&gt;那么你只需要埋头把事情做好，即可过上大家认为不错的日子。&lt;/p&gt;

&lt;p&gt;这条路是大家踩出来的，有方向有同伴，走起来不会太累，但是路途的风景确大同小异。&lt;/p&gt;

&lt;p&gt;有一部分人天生就不喜欢条条框框，以变化为美，以差异为美，那么我们是同一类人。&lt;/p&gt;

&lt;p&gt;我们希望自己去探索生命的意义，我们经常问自己为什么要这么做，&lt;/p&gt;

&lt;p&gt;我们时常在思考，这个世界是不是可以更好。&lt;/p&gt;

&lt;p&gt;但是，选择了与众不同，就要准备好面对自己选择的道路的曲折，以及周围人们的不解。&lt;/p&gt;

&lt;p&gt;我们都在荆棘中探索，希望找到一个属于自己的世外桃源。&lt;/p&gt;

&lt;p&gt;有些人会不断的来打听我们的状况然后提出一些他们认为对的意见，这些人都是好意，&lt;/p&gt;

&lt;p&gt;但是他们却不断在影响我们的决心。&lt;/p&gt;

&lt;p&gt;也许你还在路途中，也许你已经找到一个归属，&lt;/p&gt;

&lt;p&gt;让我们坚持下去的，从来不是别人的看法，&lt;/p&gt;

&lt;p&gt;而是对自己十足的信心。&lt;/p&gt;

&lt;p&gt;差异和个性从来不是我们的最终目标，&lt;/p&gt;

&lt;p&gt;我们只为不断超越和完善自己，因此我们得比自己更努力。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>Laravel中使用Redis作为队列系统的工作流程</title>
        <link>lbrb.github.io/2014/04/11/redis-queue-in-laravel.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/04/11/redis-queue-in-laravel.html</guid>
        <pubDate>Fri, 11 Apr 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;利用Redis可以很方便的实现一个任务队列，但是在Laravel中，Redis的队列总会出现一个任务多次执行的问题。究其原因是它写死了reserved的时长，也就是如果1分钟后任务没有执行完成，那么这个任务就会被重新放回队列。下面是队列的简单使用和执行原理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;设置&lt;/h2&gt;
&lt;p&gt;设置队列使用Redis非常容易，在&lt;code&gt;app/config/queue.php&lt;/code&gt;中配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&#39;default&#39; =&amp;gt; &#39;redis&#39;,
...
&#39;connections&#39; =&amp;gt; array(
    ...
    &#39;redis&#39; =&amp;gt; array(
        &#39;driver&#39; =&amp;gt; &#39;redis&#39;,
        &#39;queue&#39;  =&amp;gt; &#39;waa&#39;,
    ),
),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;使用时不需要多配置，只要写好Queue类和其fire方法，在需要的位置出队即可。具体方法可以看&lt;a href=&quot;http://laravel.com/docs/queues#basic-usage&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SendEmail {

    public function fire($job, $data)
    {
        //
        $job-&amp;gt;delete();
    }

}

Queue::push(&#39;SendEmail@send&#39;, array(&#39;message&#39; =&amp;gt; $message));
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;流程&lt;/h2&gt;
&lt;p&gt;Laravel利用artisan命令来执行出队操作，然后进行任务的执行。方法调用如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;artisan queue:work&lt;/li&gt;
  &lt;li&gt;WorkerCommand:fire()&lt;/li&gt;
  &lt;li&gt;Worker:pop()&lt;/li&gt;
  &lt;li&gt;Worker:getNextJob()&lt;/li&gt;
  &lt;li&gt;RedisQueue:pop()&lt;/li&gt;
  &lt;li&gt;Worker:process()&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我遇到的问题就在这里，在&lt;code&gt;RedisQueue:pop()&lt;/code&gt;方法中，有这样一句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$this-&amp;gt;redis-&amp;gt;zadd($queue.&#39;:reserved&#39;, $this-&amp;gt;getTime() + 60, $job);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里将当前执行的任务放到另外一个reserved队列中，超时时间是60s。也就是说，如果60s后这个任务没有被删除掉，则任务会重新被放入队列中来。因此，在实际的使用过程中，任务很可能被多次执行。解决的办法是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class SendEmail {

    public function fire($job, $data)
    {
        $job-&amp;gt;delete();
        // job 
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即先删除这个任务，再开始执行任务。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>2014阅读书单</title>
        <link>lbrb.github.io/2014/03/14/book-list-of-2014.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/03/14/book-list-of-2014.html</guid>
        <pubDate>Fri, 14 Mar 2014 00:00:00 +0800</pubDate>
        <description>
</description>
      </item>
    
      <item>
        <title>用Laravel+Grunt+Bower管理你的应用</title>
        <link>lbrb.github.io/2014/03/10/grunt-bower-and-laravel.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/03/10/grunt-bower-and-laravel.html</guid>
        <pubDate>Mon, 10 Mar 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;每个开发者都应该有自己的工具箱&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;为什么这么选择？&lt;/h2&gt;
&lt;p&gt;如今开源盛行，从后端的各个类库，到如今前端的jQuery插件，前端框架等，越来越多优秀的组件可以被我们选择应用在现有的项目中。随着开源组件的更新迭代，它们互相之间的依赖也越来越复杂。旧的框架对于新的变化总是显得难以适从，就算为了新的特性改变旧的框架，也会显的略显牵强。于是就会有新的框架和工具，在这个时候凸现出来。&lt;/p&gt;

&lt;p&gt;每个项目开始的方向是很重要的，良好的开始可以避免之后的各种问题。下面要说的三个工具，就是现有应用开发的一个良好开端。&lt;/p&gt;

&lt;h3 id=&quot;laravelhttplaravelcom&quot;&gt;&lt;a href=&quot;http://laravel.com/&quot;&gt;Laravel&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Laravel是一个非常新的PHP框架，借鉴了很多前辈的优秀特性，以PHP5为起点，引入了&lt;a href=&quot;https://getcomposer.org/&quot;&gt;Composer&lt;/a&gt;作为包管理工具，号称为WEB艺术家创造的PHP框架。&lt;/p&gt;

&lt;h3 id=&quot;grunthttpgruntjscom&quot;&gt;&lt;a href=&quot;http://gruntjs.com/&quot;&gt;Grunt&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基于JavaScript的自动化构建工具，可以将重复的任务，例如压缩（minification），编译，单元测试，linting等自动化。&lt;/p&gt;

&lt;h3 id=&quot;bowerhttpbowerio&quot;&gt;&lt;a href=&quot;http://bower.io/&quot;&gt;Bower&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Web前端开发的包管理工具，解决前端框架间的依赖关系，方便模块化和重用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;优势&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;使用Laravel可以更好的利用最新版PHP的优势，排除了一些历史问题。&lt;/li&gt;
  &lt;li&gt;利用Composer可以极大减少”轮子”的数量，优秀的包可以去&lt;a href=&quot;https://packagist.org/&quot;&gt;Packagist&lt;/a&gt;找到，这些包几乎都利用Github来托管，利用Github的issue和request可以辅助提高包的质量。&lt;/li&gt;
  &lt;li&gt;Bower可以帮助统一管理开源前端库，如Bootstrap和jQuery等，同样这些包也在Github上托管。&lt;/li&gt;
  &lt;li&gt;Grunt帮助粘合前后端的开源组件，将合并编译压缩等工作自动化。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;安装使用&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;前提&lt;/h3&gt;
&lt;p&gt;有些需要提前安装的组件这里不在赘述，请自行Google。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Composer&lt;/li&gt;
  &lt;li&gt;Node &amp;amp; npm&lt;/li&gt;
  &lt;li&gt;Grunt&lt;/li&gt;
  &lt;li&gt;Bower&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;laravel&quot;&gt;Laravel&lt;/h3&gt;
&lt;p&gt;有了Composer后安装一个Laravel项目非常容易&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;composer create-project laravel/laravel myproject
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后在&lt;code&gt;myproject&lt;/code&gt;目录下就生成了laravel的框架结构，入口文件在&lt;code&gt;public&lt;/code&gt;中。在&lt;code&gt;myproject&lt;/code&gt;根目录下，有一个&lt;code&gt;composer.json&lt;/code&gt;文件，这个文件看起来是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
    &quot;name&quot;: &quot;laravel/laravel&quot;,
    &quot;description&quot;: &quot;The Laravel Framework.&quot;,
    &quot;keywords&quot;: [&quot;framework&quot;, &quot;laravel&quot;],
    &quot;license&quot;: &quot;MIT&quot;,
    &quot;require&quot;: {
        &quot;laravel/framework&quot;: &quot;4.1.*&quot;
    },
    //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件可以控制项目的一些依赖关系，我们需要一些组件的时候直接在&lt;code&gt;require&lt;/code&gt;下添加即可，&lt;code&gt;composer&lt;/code&gt;会帮我们去查找这个组件所需的依赖包。&lt;/p&gt;

&lt;p&gt;接着为了安装前端框架，我们先来创建几个公共目录，在&lt;code&gt;public&lt;/code&gt;下，创建类似的目录&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- assets
|   |-- css
|   |-- fonts
|   `-- js
|-- favicon.ico
|-- index.php
|-- packages
`-- robots.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里只有&lt;code&gt;assets&lt;/code&gt;目录是我新创建的&lt;/p&gt;

&lt;h3 id=&quot;bower&quot;&gt;Bower&lt;/h3&gt;
&lt;p&gt;准备好后端框架以后，可以安装前端框架了，例如&lt;code&gt;Bootstrap&lt;/code&gt;。利用&lt;code&gt;Bower&lt;/code&gt;安装的前端库是其整个工程，并不是我们需要的个别文件，所以可以讲它们先放在一个位置，之后利用&lt;code&gt;Grunt&lt;/code&gt;来统一处理。&lt;/p&gt;

&lt;p&gt;首先配置一下安装路径，在&lt;code&gt;myproject&lt;/code&gt;根目录下配置文件&lt;code&gt;.bowerrc&lt;/code&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;directory&quot;: &quot;public/assets/bower&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件告诉bower，将下载的包都安装到&lt;code&gt;public/assets/bower&lt;/code&gt;下。&lt;/p&gt;

&lt;p&gt;接着在根目录创建一个&lt;code&gt;bower&lt;/code&gt;的配置文件&lt;code&gt;bower.json&lt;/code&gt;为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;myproject&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着添加前端库&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install bootstrap -S
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令将会利用配置文件管理整个库依赖，这个时候再看一下配置文件，bower已经帮助我们自动安装好了&lt;code&gt;Bootstrap&lt;/code&gt;依赖的包–&lt;code&gt;jQuery&lt;/code&gt;，同时修改了配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;myproject&quot;,
  &quot;dependencies&quot;: {
    &quot;bootstrap&quot;: &quot;~3.1.1&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在看一下目标目录，&lt;code&gt;public/assets&lt;/code&gt;下，生成了一个bower目录，其中包含了&lt;code&gt;Bootstrap&lt;/code&gt;和&lt;code&gt;jQuery&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;grunt&quot;&gt;Grunt&lt;/h3&gt;
&lt;p&gt;根据上面的步骤，我们很方便的建立了后端框架和前端框架，但是前端框架在使用的时候直接用&lt;code&gt;bower&lt;/code&gt;下的文件并不是非常方便，而且还可能会涉及到一些库的合并压缩等步骤。这些问题都可以交给&lt;code&gt;Grunt&lt;/code&gt;去做.&lt;/p&gt;

&lt;p&gt;首先在&lt;code&gt;myproject&lt;/code&gt;根目录下利用&lt;code&gt;npm init&lt;/code&gt;初始化一个配置文件。根据提示一步一步填写即可，最后生成的配置文件&lt;code&gt;package.json&lt;/code&gt;应该如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;myproject&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;Gruntfile.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有不一样的地方不用担心，尽管修改即可。&lt;/p&gt;

&lt;p&gt;接着我们要安装一些Grunt的插件，帮助我们更好的完成所需功能。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm install grunt --save-dev
npm install grunt-contrib-concat --save-dev
npm install grunt-contrib-less --save-dev
npm install grunt-contrib-uglify --save-dev
npm install grunt-contrib-watch --save-dev
npm install grunt-contrib-copy --save-dev
npm install grunt-contrib-cssmin --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的每个插件我会在下面的配置中介绍。上面命令中的&lt;code&gt;--save-dev&lt;/code&gt;选项的作用是将安装的这些包放入配置文件依赖项中，方便以后安装。下面是安装后的配置文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;{
  &quot;name&quot;: &quot;myproject&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;Gruntfile.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;grunt&quot;: &quot;~0.4.3&quot;,
    &quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,
    &quot;grunt-contrib-less&quot;: &quot;~0.10.0&quot;,
    &quot;grunt-contrib-uglify&quot;: &quot;~0.4.0&quot;,
    &quot;grunt-contrib-watch&quot;: &quot;~0.5.3&quot;,
    &quot;grunt-contrib-cssmin&quot;: &quot;~0.9.0&quot;
    &quot;grunt-contrib-copy&quot;: &quot;~0.5.0&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在安装后有了一个&lt;code&gt;node_modules&lt;/code&gt;目录，这个是node项目依赖包的位置，我们一般都在本地进行文件的合并和压缩，所以可以将这个包保留在本地。另外对于&lt;code&gt;bower&lt;/code&gt;生成的目录，在&lt;code&gt;Grunt&lt;/code&gt;处理过以后也是可以不上传到正式环境中的。所以修改&lt;code&gt;.gitignore&lt;/code&gt;文件，将这两个文件夹排除出去：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/bootstrap/compiled.php
/vendor
composer.phar
composer.lock
.env.local.php
.env.php
.DS_Store
Thumbs.db
/public/assets/bower
/node_modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来就要进行&lt;code&gt;Grunt&lt;/code&gt;的配置项编写了，我会在配置中加入注释帮助理解。还记得我们刚刚建立的&lt;code&gt;package.json&lt;/code&gt;配置文件中的入口文件吗？这个文件还不存在，所以我们需要手动建立，在&lt;code&gt;myproject&lt;/code&gt;下创建&lt;code&gt;Gruntfile.js&lt;/code&gt;的文件，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;module.exports = function(grunt) {
  //配置项
  grunt.initConfig({
    //concat插件配置，用来合并多个文件
    concat: {
      //文件间的分隔符
      options: {
        separator: &#39;;&#39;,
      },
      //app是一个任务名，可以随意命名
      app: {
        //将进行的合并项
        src: [
          &#39;./public/assets/bower/jquery/dist/jquery.js&#39;,
          &#39;./public/assets/bower/bootstrap/dist/js/bootstrap.js&#39;,
        ],
        //合并后放置在
        dest: &#39;./public/assets/js/javascript.js&#39;,
      },
    },
    //css合并压缩
    cssmin: {
      //任务名
      app: {
        src: [
          &#39;./public/assets/bower/bootstrap/dist/css/bootstrap.css&#39;,
          &#39;./public/assets/css/base.css&#39;
        ],
        dest: &#39;./public/assets/css/stylesheet.css&#39;
      }
    },
    //js压缩
    uglify: {
      options: {
        mangle: false //是否混合变量，如果需求的话置为true
      },
      app: {
        files: {
          &#39;./public/assets/js/javascript.js&#39;: &#39;./public/assets/js/javascript.js&#39;,
        }
      },
    },
    //移动文件
    copy: {
      app: {
        files: [
          {
            expand: true,
            flatten: true,
            cwd: &#39;./public/assets/bower/bootstrap/fonts/&#39;,
            src: [&#39;**&#39;], 
            dest: &#39;./public/assets/fonts/&#39;, 
            filter: &#39;isFile&#39;
          },
        ]
      }
    },
    //监听文件变化，如果文件变化，将重新进行任务
    watch: {
      app: {
        files: [
          &#39;./public/assets/bower/jquery/dist/jquery.js&#39;,
          &#39;./public/assets/bower/bootstrap/dist/js/bootstrap.js&#39;,
          &#39;./public/assets/bower/bootstrap/dist/css/bootstrap.css&#39;,
        ],   
        //文件变化后执行哪些任务
        tasks: [&#39;concat:app&#39;,&#39;uglify:app&#39;,&#39;cssmin:app&#39;,&#39;copy:app&#39;],
        options: {
          livereload: true
        }
      },
    }
  });

  //导入所需的插件
  grunt.loadNpmTasks(&#39;grunt-contrib-concat&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-watch&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-less&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-uglify&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-copy&#39;);
  grunt.loadNpmTasks(&#39;grunt-contrib-cssmin&#39;);

  //注册两个任务
  grunt.registerTask(&#39;watch&#39;, [&#39;watch&#39;]);
  grunt.registerTask(&#39;default&#39;, [&#39;concat:app&#39;,&#39;uglify:app&#39;,&#39;cssmin:app&#39;,&#39;copy:app&#39;]);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到，最后注册了两个任务，这两个任务可以从终端中执行，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以开启文件监听，当文件变化时执行watch中设定的任务。&lt;/p&gt;

&lt;p&gt;如果直接执行&lt;code&gt;grunt&lt;/code&gt;，则会执行&lt;code&gt;default&lt;/code&gt;中设定的任务。我们也可以具体指定执行某一单一任务，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;grunt copy:app
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面则只将&lt;code&gt;bootstrap/fonts&lt;/code&gt;中的文件拷贝到&lt;code&gt;public/assets/fonts&lt;/code&gt;中。&lt;/p&gt;

&lt;p&gt;对于上述的这些插件，可以在&lt;a href=&quot;http://gruntjs.com/plugins&quot;&gt;这里&lt;/a&gt;找到，也有详细的用法。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;每个人都有自己的喜好，我的这种配置可能只抛个砖，希望有更好的方式分享。最后在总结一下这三剑客：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Laravel利用了最新PHP特性，引入了Composer包管理，解决后端库之间的依赖&lt;/li&gt;
  &lt;li&gt;Bower帮助安装和解决前端框架和库的依赖关系&lt;/li&gt;
  &lt;li&gt;Grunt帮助粘合前后端的开源组件，并且完成合并和压缩等重复性工作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面两篇参考文章各有特色，如果希望了解一下可以点击链接去看。&lt;/p&gt;

&lt;p&gt;我在&lt;a href=&quot;https://github.com/suyan/Laravel-Bower-Grunt&quot;&gt;Github&lt;/a&gt;上建立了这篇博客中所讲的目录结构，想要快速建立一个可使用的工程，只需要以下几部：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/suyan/Laravel-Bower-Grunt.git
composer install
bower update
npm install
grunt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enjoy it!&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.terrymatula.com/development/2013/how-i-use-bower-and-grunt-with-my-laravel-projects/&quot;&gt;How I use Bower and Grunt with my Laravel projects&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.elenakolevska.com/using-grunt-with-laravel-and-bootstrap/&quot;&gt;Using Grunt + Bower with Laravel and Bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>在Github上搭建Jekyll博客和创建主题</title>
        <link>lbrb.github.io/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/02/12/how-to-deploy-a-blog-on-github-by-jekyll.html</guid>
        <pubDate>Wed, 12 Feb 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;之前本来想展开写的，后来发现Jekyll官网的教程已经非常完善了就没有多写，所以只有&lt;a href=&quot;/2013/04/23/deploy-jeklly-blog.html&quot;&gt;这篇&lt;/a&gt;。&lt;br /&gt;
但是过了这么久，发现很多人还是不清楚怎么搭建，所以这里打算详细写一下，并且把自己对图片的解决方案以及主题的创建步骤也一并写下。&lt;/p&gt;

  &lt;p&gt;本篇主要谈如何搭建，不再讲为什么用它们。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;说明：本篇用到的代码中，为了防止解析冲突，一律多了&lt;code&gt;\&lt;/code&gt;这个来防止被误解析&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;创建一个库&lt;/h2&gt;
&lt;p&gt;在Github上新开一个库，名字叫做&lt;code&gt;username.github.io&lt;/code&gt;，然后当别人在地址栏输入相应url的时候就可以访问进来了。&lt;/p&gt;

&lt;p&gt;在这个库中完全可以只上传一个&lt;code&gt;index.html&lt;/code&gt;，来讲自己要写的东西写进去，但是这样会丧失很多灵活性，所以需要Jekyll的帮助来创建自己的博客。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;设定目录结构&lt;/h2&gt;
&lt;p&gt;把自己的库clone到本地来，建立如下目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── CNAME
├── README.md
├── _config.yml
├── _includes
│   ├── disqus.html
│   ├── footer.html
│   ├── googleanalytics.html
│   ├── header.html
│   └── navside.html
├── _layouts
│   ├── base.html
│   ├── book.html
│   ├── page.html
│   └── post.html
├── _posts
│   ├── Book
│   ├── Life
│   ├── Resource
│   ├── Technology
│   └── Tool
├── index.html
├── pages
│   ├── about.html
│   ├── archive.html
│   └── atom.xml
├── public
│   ├── css
│   ├── fonts
│   ├── img
│   ├── js
│   └── upload
└── sitemap.txt

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个目录结构是我自己设定的，也可以有不同的目录结构，看&lt;a href=&quot;http://jekyllrb.com/docs/structure/&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;接下来我主要解释这里面每一个目录的功能。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;_config.yml&lt;/code&gt;里写有整个站点的主要配置项，我的如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;permalink: /:year/:month/:day/:title.html   #博文的固定链接
paginate: 10                                #分页时每页博文数量
author:                                     #自定义常亮
  name: 闫肃
  email: yansu0711@gmail.com
  link: http://yansu.org
title: 闫肃的博客                             #自定义常量
locals:                                     #自定义常量
  tags: 标签
  about: 关于
active: 技术                                 #自定义常量
subscribe_rss: /pages/atom.xml              #订阅地址
markdown: redcarpet                         #markdown解释器
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的自定义常量可以在模板中使用，以后有修改的时候就不需要跑去改代码了。尤其是对一些私人的选项，可以在这里定义。现在我的博客中出了disqus和googleanalytics外都直接在这里设定就好了。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;域名配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CNAME&lt;/code&gt;这个文件写明了这个站点的域名，如果不喜欢&lt;code&gt;username.github.io&lt;/code&gt;的话，可以像我一样改掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yansu.org
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改法只要在这个文件中写入域名就可以了。不过你需要去域名服务商那里设定域名解析规则。&lt;/p&gt;

&lt;p&gt;只要把&lt;code&gt;主机记录&lt;/code&gt;为&lt;code&gt;@&lt;/code&gt;,&lt;code&gt;www&lt;/code&gt;的记录值写成&lt;code&gt;username.github.io&lt;/code&gt;就好了。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;博客存放&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;_posts&lt;/code&gt;下的所有目录中的所有博客，都会被Jekyll处理成为静态的html文件，然后放在&lt;code&gt;_site&lt;/code&gt;下。我这里没有&lt;code&gt;_site&lt;/code&gt;目录，是因为我在&lt;code&gt;.gitignore&lt;/code&gt;文件中把这个目录屏蔽掉了，它不会上传到Github上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;_site/
_drafts/
.DS_Store
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上是我的&lt;code&gt;.gitignore&lt;/code&gt;文件内容。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;_posts&lt;/code&gt;下的符合&lt;code&gt;YYYY-MM-DD-xxxxxx.md&lt;/code&gt;的文件，都会被Jekyll认定为博客内容。我在&lt;code&gt;_posts&lt;/code&gt;下又新建了一些文件夹，主要是方便自己本地管理博客。&lt;/p&gt;

&lt;p&gt;在上述这些文件中，必须先定义一些配置项，例如这篇博客的md文件中，开头是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
layout: post                                   #这个博客的布局文件
title: 在Github上搭建自己的Jekyll博客             #博客标题
category: 工具                                  #博客分类
tags: Jekyll                                   #博客标签
keywords: Jekyll,Github                        #自定义常量
description:                                   #自定义常量

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了自定义常量外的必须包含进去，自定义变量在这个布局中可以访问。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;模版文件&lt;/h3&gt;
&lt;p&gt;剩余的目录，基本都属于模板文件了，我解释一下各自的作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;_includes&lt;/code&gt; 可以在模板中随时包含的文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;_layouts&lt;/code&gt; 布局文件，在博客头配置中可以选择&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;pages&lt;/code&gt; 站内固定的页面&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;public&lt;/code&gt; 公共资源，包括&lt;code&gt;js&lt;/code&gt;,&lt;code&gt;css&lt;/code&gt;,&lt;code&gt;img&lt;/code&gt;等，还有我博客中调用的图片，我都放这里&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;index.html&lt;/code&gt; 站点的首页，整个站的入口文件&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;sitemap.txt&lt;/code&gt; 给搜索引擎看的，如何爬取这个站&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;创建自己的主题&lt;/h2&gt;
&lt;p&gt;上面讲了如何布局好站内文件结构，接下来主要就是如何创建一个自己的主题了。&lt;/p&gt;

&lt;p&gt;布局文件是整个主题最重要的文件，这些文件告诉Jekyll如何去形成一个html页面。&lt;/p&gt;

&lt;p&gt;首先我说一下我最基础的&lt;code&gt;page.html&lt;/code&gt;文件，因为它决定了入口文件&lt;code&gt;index.html&lt;/code&gt;的布局。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
layout: base

&amp;lt;div class=&quot;row&quot;&amp;gt;
  &amp;lt;div class=&quot;col-md-12 aside3-title&quot;&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;h2 id=&quot;#identifier&quot;&amp;gt;{\{ page.title }}&amp;lt;/h2&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;col-md-12 aside3-content&quot;&amp;gt;
    &amp;lt;div id=&quot;page-content&quot;&amp;gt;
      {\{ content }}
    &amp;lt;/div&amp;gt;
    &amp;lt;hr&amp;gt;
    {\% include disqus.html %}
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从这里可以看到这个文件写起来一点都不复杂，但是为什么开头还有个&lt;code&gt;layout&lt;/code&gt;呢？因为它也不是最基本的布局文件，最基本的是&lt;code&gt;base.html&lt;/code&gt;，我们看一下它的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  {\% include header.html %}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;row&quot;&amp;gt;
      {\% include navside.html %}
      &amp;lt;div class=&quot;col-md-8 col-lg-8 col-sm-12 col-xs-12 aside3&quot;&amp;gt;
        &amp;lt;div id=&quot;container&quot;&amp;gt;
          &amp;lt;div id=&quot;pjax&quot;&amp;gt;
            {\{ content }}
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  {\% include footer.html %}
  {\% include googleanalytics.html %}
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个文件就更像一个HTML文件了，用PHP或者Python写过web应用的人看到&lt;code&gt;{\% %}&lt;/code&gt;这样的标签应该不陌生，这不就是模板标签嘛。其实Jekyll也是借用了一下模板系统的，官网说明在&lt;a href=&quot;http://jekyllrb.com/docs/templates/&quot;&gt;这里&lt;/a&gt;，看到开头第一句讲的它用了&lt;a href=&quot;http://docs.shopify.com/themes/liquid-basics&quot;&gt;Liquid&lt;/a&gt;了吧。如果Jekyll的文档不能满足你的话，可以去Liquid那里查查。&lt;/p&gt;

&lt;p&gt;我解释一下&lt;code&gt;base.html&lt;/code&gt;中几个标签的功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;{\% include header.html %}&lt;/code&gt; 从&lt;code&gt;_includes&lt;/code&gt;中把&lt;code&gt;header.html&lt;/code&gt;包含进来放在这里&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;{\% include navside.html %}&lt;/code&gt; 同上&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;{\{ content }}&lt;/code&gt; 这句的作用是将继承这个Layout的文件中的代码，放在这里&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以再看&lt;code&gt;page.html&lt;/code&gt;文件就很容易了，它就是把配置项下面的内容，填补到&lt;code&gt;base.html&lt;/code&gt;中的&lt;code&gt;{\{ content }}&lt;/code&gt;处形成了一个文件。那么&lt;code&gt;page.html&lt;/code&gt;中的&lt;code&gt;{\{ content }}&lt;/code&gt;做什么用呢？因为别人也可以以&lt;code&gt;page.html&lt;/code&gt;来作为自己的布局文件。&lt;/p&gt;

&lt;p&gt;入口文件&lt;code&gt;index.html&lt;/code&gt;就是这么干的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;layout: page
title: 首页
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里看到选择了page作为布局文件，那么title干嘛用的呢？其实它是在被包含的&lt;code&gt;header.html&lt;/code&gt;中被用到了。来看看&lt;code&gt;header.html&lt;/code&gt;怎么写的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;{\{ page.title }} | {\{ site.title }}&amp;lt;/title&amp;gt;
&amp;lt;meta name=&quot;author&quot; content=&quot;梁彬&quot;&amp;gt;
{\% if page.keywords %}
  &amp;lt;meta name=&quot;keywords&quot; content=&quot;Jekyll,Github&quot;&amp;gt;
{\% endif %}
{\% if page.description  %}
  &amp;lt;meta name=&quot;description &quot; content=&quot;&quot;&amp;gt;
{\% endif %}

...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里又使用了一些新标签——&lt;code&gt;{\{ }\}&lt;/code&gt;，这个标签就是用来书写变量的，通过在配置处配置变量，或者使用系统的自定义变量，可以轻松改变页面内的一些元素或者内容。&lt;/p&gt;

&lt;p&gt;系统变量查询可以去&lt;a href=&quot;http://jekyllrb.com/docs/variables/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实整个主题书写就是这么简单，如果有不清楚的可以再看看官网的文档。动一动手就非常明白了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;插入图片&lt;/h2&gt;
&lt;p&gt;很多人感觉用Jekyll最不方便的就是插入图片了，其实我也是这么觉得的。所以只能自己去想些办法。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;图片统一存放&lt;/h3&gt;
&lt;p&gt;图片我都放在了&lt;code&gt;/public/upload&lt;/code&gt;下，所以我在插入图片的时候只要用&lt;code&gt;![xxx](http://yansu-uploads.stor.sinaapp.com/imgs/xxx)&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;方便的图片导入&lt;/h3&gt;
&lt;p&gt;导入图片的方式是我将&lt;code&gt;upload&lt;/code&gt;文件夹做了个软连接，放到mac的dock上就行了，有图片要用的时候直接往里面一拖。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;方便的截图&lt;/h3&gt;
&lt;p&gt;很多时候图片都是现截取的，比如用QQ的截图工具，或者系统的截图工具，但是他们截取完都存放在了&lt;code&gt;user/Pictures&lt;/code&gt;里面，来回移动太累了。我这里介绍一个Mac下的一个工具——Trickster，看图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://yansu-uploads.stor.sinaapp.com/imgs/trickster-move-picture.png&quot; alt=&quot;移动图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个工具可以看到刚刚修改过的图片，而且还有一个收藏的文件夹，我每次截取完图以后，从左边往右边一拖，然后在markdown中就可以继续书写了。一点都不耗时。&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;本地预览及提交&lt;/h2&gt;
&lt;p&gt;本地预览自己的修改很容易，只要进入&lt;code&gt;username.github.io&lt;/code&gt;目录，执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jekyll serve
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后访问&lt;code&gt;http://localhost:4000&lt;/code&gt;就OK了，安装Jekyll的方式自行谷歌吧…&lt;/p&gt;

&lt;p&gt;自己预览过没有问题以后，就提交到服务端吧，Git三步走&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git add xxx
git commit -m &quot;xxx&quot;
git push
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-12&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;我觉得自己的这个主题设定的算是比较好修改和移植的了，如果大家有什么问题，可以尽管问。&lt;/p&gt;

&lt;p&gt;另外一些特别的功能，比如三栏、评论、谷歌分析，这些都不难，相信你稍微打开Github读一下这个主题的代码就很快明白了。&lt;/p&gt;

&lt;p&gt;代码地址戳&lt;a href=&quot;https://github.com/suyan/suyan.github.io&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>了解GitHub工作流【译】</title>
        <link>lbrb.github.io/2014/01/30/understanding-the-github-workflow.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/30/understanding-the-github-workflow.html</guid>
        <pubDate>Thu, 30 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;GitHub流是一个轻量级，基于分支的工作流，它使得小组和项目的部署变得标准化。这个向导解释了GitHub流是如何&amp;amp;为什么工作的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7u2ho6.com1.z0.glb.clouddn.com/github-flow.png&quot; alt=&quot;github-flow&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;创建一个分支&lt;/h2&gt;
&lt;p&gt;当你工作在一个项目中，你可能会在任何时间产生不同的想法和特性计划–这些都是准备完成的，或者其他不准备完成的。分支的存在可以帮助你管理工作流。&lt;/p&gt;

&lt;p&gt;当你在自己的项目中创建一个分支的时候，也就等于创建了一个尝试自己想法的环境。你在这个分支修改的东西不会影响到主分支，所以你可以尽情的测试和提交改变。这些改变直到你的合作伙伴审查过，确保安全才会被合并到主分支中。&lt;/p&gt;

&lt;p&gt;分支是Git的一个核心概念，并且GitHub流完全基于这个概念。只有一个规则，&lt;strong&gt;那就是&lt;code&gt;master&lt;/code&gt;分支必须是可部署的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此，当你在修复bug或者创建新功能时，你的新分支必须创建在master之外。你的分支名称应该是自描述的（如：&lt;code&gt;refactor-authentication&lt;/code&gt;，&lt;code&gt;user-content-cache-key&lt;/code&gt;，&lt;code&gt;make-retina-avatars&lt;/code&gt;），所以其他人可以了解什么正在进行。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;增加提交&lt;/h2&gt;
&lt;p&gt;一但你的分支创建完成，就可以进行修改了。不管你进行了增加、修改或者删除一个文件，你都可以进行提交代码，将他们增加到分支中去。这个过程可以保持跟踪你对一个特性分支工作的发展。&lt;/p&gt;

&lt;p&gt;提交同样为你的项目创建了一个清晰的历史，这样别人就可以了解你做这些的原因以及内容。每一个提交有一个相关的描述，这个描述可以解释你具体做了什么修改。另外，每一个提交都应该是分开的修改单元。这个使得你可以在发现bug的时候回滚修改，或者你决定朝向不同的方向。&lt;/p&gt;

&lt;p&gt;提交描述是非常重要的，尤其因为Git跟踪你的改变并且在他们被推送到服务器上的时候显示他们。通过写出清楚的提交描述，你可以使得别人容易遵从和提供反馈。&lt;/p&gt;

&lt;h2 id=&quot;pull-request&quot;&gt;开启一个Pull Request&lt;/h2&gt;
&lt;p&gt;Pull Request最初开始于对你的提交的讨论。因为他们紧密集成在Git库下，如果你的请求被接受，所有人可以看到被合并的改变具体包含什么。&lt;/p&gt;

&lt;p&gt;你可以开启一个Pull Request在开发过程工任何部分：当你有少量代码，或者你希望分享一些截图或平常的想法，或者当你被卡住希望获得帮助及建议，又或者当你准备好让别人来审查你的工作。通过在请求描述中使用GitHub的 @方式 ，你可以向某一个人或者团队要求反馈，不论他们不在线或者在别的时区。&lt;/p&gt;

&lt;p&gt;Pull Request对于开元项目的管理和分享都非常有用。如果你使用一个Fork&amp;amp;Pull模型，Pull Request提供了一个方式来告知项目管理者他们希望关注的改变。如果你使用Shared repository Model，Pull Request有助于开始审查和讨论即将合并到master分支的改变。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;讨论并审核你的代码&lt;/h2&gt;
&lt;p&gt;一但一个Pull Request被开启，负责审核代码改变的人们或团队可能会有一些问题或者评论。可能代码风格不符合项目指导，修改缺少单元测试，或者所有修改都做的非常好。Pull Request被设计来促进和不活这种类型的会话。&lt;/p&gt;

&lt;p&gt;在对你提交进行讨论和反馈的过程中，你可以继续推送你的分支。如果有人评论你忘了做一些事情，或者有一些bug在你的代码中，你可以在自己分支中修复并且推送这些修改。GitHub将在统一的Pull Request视图中给你显示新的提交和其他额外的反馈。&lt;/p&gt;

&lt;p&gt;Pull Request评论用Markdown写成，所以你可以嵌入图片和表情符号，使用pre-formatted的文字块，和高亮的格式。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;合并和部署&lt;/h2&gt;
&lt;p&gt;一但你的Pull Request审核通过并且分支通过测试，这些代码就可以被合并到master分支以便部署。如果你需要在合并到GitHub库前进行测试，你可以在本地先进行合并。这些在你推送到库中前都是非常容易控制的。&lt;/p&gt;

&lt;p&gt;一但被合并，Pull Request会对你的代码保存一个历史修改记录。因为它们是可搜索的，所以所有人都可以回顾到历史纪录去了解一个决定是为什么或者怎么完成的。&lt;/p&gt;

&lt;p&gt;通过在Pull Request的文字中包含某些关键字，你可以关联代码和issues。当你的Pull Request被合并，相关的issues同样会被关闭。比如，输入&lt;code&gt;Closes #32&lt;/code&gt;将会关闭库中的32号issue。想要获得更多信息，点[这里][2]。&lt;/p&gt;

&lt;p&gt;原文链接：[http://guides.github.com/overviews/flow/][1]&lt;br /&gt;
[1]: http://guides.github.com/overviews/flow/&lt;br /&gt;
[2]: https://help.github.com/articles/closing-issues-via-commit-messages&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>Shell 常用资源</title>
        <link>lbrb.github.io/2014/01/15/general-shell-resources.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/15/general-shell-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;常用指令&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;文本内容搜索&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;grep aaa * 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;文件夹操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;查看文件夹大小   du -h --max-depth=1 /home/ys
查看驱动器空间   df -h 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;压缩命令&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;tar zxvf aaa.tar.gz
tar zcvf aaa.tar.gz aaa
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;登陆到其他用户&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;login
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;查看端口的占用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lsof -i:8087  查看8087端口的使用
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;批量杀死进程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ps -aux|grep name|grep -v grep|cut -c 9-15|xargs kill -9
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;查看当前时间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;date       时间
date +%s   时间戳
date -d &quot;2010-07-20 10:25:30&quot; +%s  指定时间时间戳
date -d &quot;@1279592730&quot;    时间戳转时间
date -d &quot;1970-01-01 14781 days&quot; &quot;+%Y/%m/%d %H:%M:%S&quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;查看进程内存使用情况&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;top -d 1 -p pid [,pid ...]
pmap pid 
ps aux|grep process_name
查看/proc/process_id/文件夹下的status文件
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;linux&quot;&gt;查看Linux内核版本或发布版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lsb_release -a
uname -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;http&quot;&gt;一句话实现一个HTTP服务，把当前文件夹作为根目录&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;python -m SimpleHTTPServer
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;查看本地网络服务活动状态&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;lsof -i
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;ip&quot;&gt;查看自己的外网ip&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;curl ifconfig.me
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;下载整个网站&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;wget --random-wait -r -p -e robots=off -U mozilla http://www.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-11&quot;&gt;后台运行一段不中止的程序，并可随时查看它的状态&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;screen -d -m -S some_ name ping my_router
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-12&quot;&gt;查看进程执行的时间&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ps -A -opid,stime,etime,args | grep python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;创建守护进程&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nohup python /var/www/a.py &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-14&quot;&gt;查看当前文件夹下文件（文件夹）大小&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;du -h --max-depth=1 .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-15&quot;&gt;查看所有磁盘大小&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;df -h
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-16&quot;&gt;诊断网络&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;mtr 
ping
traceroute
dig
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-17&quot;&gt;列出本机监听的端口号&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;netstat –tlnp
netstat -anop
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-18&quot;&gt;在远程机器上运行一段脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;ssh user@server bash &amp;lt; /path/to/local/script.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-19&quot;&gt;端口扫描&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;nc -z -v -n 127.0.0.1 20-100
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;google20&quot;&gt;负载测试，30秒内向Google发起20个并发连接&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;siege -c20 www.google.co.uk -b -t30s
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>jQuery 常用资源</title>
        <link>lbrb.github.io/2014/01/15/general-jquery-resources.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/15/general-jquery-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;官方资源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jquery.com/&quot;&gt;官方首页&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://plugins.jquery.com/&quot;&gt;官方插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;下拉框扩展&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://ivaynberg.github.io/select2/&quot;&gt;Select 2&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;功能强大的下拉列表插件，基本包含了所有可能的需求……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://kotowicz.net/jquery-option-tree/demo/demo.html&quot;&gt;OptionTree&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;联动下拉列表插件，可以动态生成下拉列表，而且支持ajax获取数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;常用代码&lt;/h2&gt;

&lt;h3 id=&quot;a&quot;&gt;禁用a的链接&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;href=&quot;return false;&quot;或href=&quot;javascript;&quot;
$().live(&#39;click&#39;,function(e){
  e.preventDefault();
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;file&quot;&gt;清空file的内容&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var cfile = $(&#39;#id&#39;).clone();
$(&#39;#id&#39;).replaceWith(cfile);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jqueryformjs--jqueryvalidatejs&quot;&gt;jquery.form.js 和 jquery.validate.js配合使用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;这两个脚本搭配在表单验证和提交是非常的好用,顺便增加了对bootstrap表单的支持
$(&quot;#page_form&quot;).validate({
  highlight: function(element) {
    $(element).closest(&#39;.control-group&#39;).removeClass(&#39;success&#39;).addClass(&#39;error&#39;);
  },
  success: function(element) {
    element.text(&#39;OK!&#39;).addClass(&#39;valid&#39;).closest(&#39;.control-group&#39;).removeClass(&#39;error&#39;).addClass(&#39;success&#39;);
  },
  submitHandler:function(form) {
    $(form).ajaxSubmit(options);
}});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;选择父节点&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;使用$(this)来将dom对象转为jquery对象
$(this).parents(&#39;tr&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;多重操作&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$(this).parents(&#39;tr&#39;).remove();
因为jquery函数返回jquery节点
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>JavaScript 常用资源</title>
        <link>lbrb.github.io/2014/01/15/general-javascript-resources.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/15/general-javascript-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;常用代码&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;字符串截取&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;substr(start [, length ])
返回一个从指定位置开始的指定长度的子字符串
substring(start, end)
返回位于 String 对象中指定位置的子字符串。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;页面跳转&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;window.navigate(&quot;top.jsp&quot;);
window.history.back(-1);
window.location.href=&quot;login.jsp?backurl=&quot;+window.location.href; 
self.location=&#39;top.htm&#39;;
top.location=&#39;xx.jsp&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;加载完成&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;window.onload 
必须等页面内包括图片的所有元素加载完成后才能执行。
不能同时编写多个，只执行一个
$(document).ready()
是DOM结构绘制完毕后就可以执行
可以编写多个
简写$(function(){});
$(window).load()等同与window.onload
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;刷新页面&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;history.go(0) 
location.reload() 
location=location 
location.assign(location) 
document.execCommand(&#39;Refresh&#39;) 
window.navigate(location) 
location.replace(location) 
document.URL=location.href 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;json&quot;&gt;json转化和解析&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;JSON.parse(&quot;{a:&#39;111&#39;,b:&#39;ccc&#39;}&quot;);  //解析
eval(&quot;(&quot;+&quot;&quot;+&quot;)&quot;); //解析
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;时间转换&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var day1 = parseInt(new Date().valueOf()/1000); //获得当前时间时间戳
day2 = new Date(day1*1000);
alert(day2.getFullYear()+&quot;-&quot;+(day2.getMonth()+1)+&quot;-&quot;+day2.getDate()+&quot; &quot;+day2.getHours()+&quot;:&quot;+day2.getMinutes()+&quot;:&quot;+day2.getSeconds())
d = new Date();
s = d.getFullYear() + &quot;-&quot;;
s += (&quot;0&quot;+(d.getMonth()+1)).slice(-2) + &quot;-&quot;;
s += (&quot;0&quot;+d.getDate()).slice(-2) + &quot; &quot;;
s += (&quot;0&quot;+d.getHours()).slice(-2) + &quot;:&quot;;
s += (&quot;0&quot;+d.getMinutes()).slice(-2) + &quot;:&quot;;
s += (&quot;0&quot;+d.getSeconds()).slice(-2) + &quot;.&quot;;
s += (&quot;00&quot;+d.getMilliseconds()).slice(-3);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;uri&quot;&gt;URI编码转换&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var a=&quot;&#39;:&#39;&quot;;
en = encodeURI(a);    //编码
a = decodeURI(en);    //解码
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;html&quot;&gt;HTML编码转换&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function htmlEncode(value){
  return $(&#39;&amp;lt;div/&amp;gt;&#39;).text(value).html();
}

function htmlDecode(value){
  return $(&#39;&amp;lt;div/&amp;gt;&#39;).html(value).text();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>Git 常用资源</title>
        <link>lbrb.github.io/2014/01/15/general-git-resources.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/15/general-git-resources.html</guid>
        <pubDate>Wed, 15 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;git&quot;&gt;Git常用操作&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;查看历史&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git log --pretty=oneline filename // 一行显示
git show xxxx // 查看某次修改
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;创建分支&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git branch develop // 只创建分支
git checkout -b master develop // 创建并切换到 develop 分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;合并分支&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git checkout master // 切换到主分支
git merge --no-ff develop // 把 develop 合并到 master 分支，no-ff 选项的作用是保留原分支记录
git rebase develop // 合并分支
git branch -d develop // 删除 develop 分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;标签功能&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;git tag // 显示所有标签
git tag -l &#39;v1.4.2.*&#39; // 显示 1.4.2 开头标签
git tag v1.3 // 简单打标签   
git tag -a v1.2 9fceb02 // 后期加注标签
git tag -a v1.4 -m &#39;my version 1.4&#39; // 增加标签并注释， -a 为 annotated 缩写
git show v1.4 // 查看某一标签详情
git push origin v1.5 // 分享某个标签
git push origin --tags // 分享所有标签
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;回滚操作&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;reset --hard v0.1
reflog
reset --hard v0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;取消某个文件的修改&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git checkout -- &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;删除文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git rm &amp;lt;filename&amp;gt;   直接删除文件
git rm --cached &amp;lt;filename&amp;gt;    删除文件暂存状态
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;移动文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git mv &amp;lt;sourcefile&amp;gt; &amp;lt;destfile&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;查看文件更新&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git diff              查看未暂存的文件更新 
git diff --cached     查看已暂存文件的更新 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;克隆远程分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git branch -r
git checkout origin/android
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;develop&quot;&gt;修复develop上的合并错误&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;将merge前的commit创建一个分之，保留merge后代码&lt;/li&gt;
  &lt;li&gt;将develop &lt;code&gt;reset --force&lt;/code&gt;到merge前，然后&lt;code&gt;push --force&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在分支中rebase develop&lt;/li&gt;
  &lt;li&gt;将分支push到服务器上重新merge&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;git-1&quot;&gt;Git设置&lt;/h2&gt;

&lt;p&gt;Git的全局设置在&lt;code&gt;~/.gitconfig&lt;/code&gt;中，单独设置在&lt;code&gt;project/.git/config&lt;/code&gt;下。&lt;/p&gt;

&lt;p&gt;忽略设置全局在&lt;code&gt;~/.gitignore_global&lt;/code&gt;中，单独设置在&lt;code&gt;project/.gitignore&lt;/code&gt;下。&lt;/p&gt;

&lt;h3 id=&quot;commit-&quot;&gt;设置 commit 的用户和邮箱&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;[user]
    name = xxx
    email = xxx@xxx.com
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>2013个人总结</title>
        <link>lbrb.github.io/2014/01/02/my-2013.html</link>
        <guid isPermaLink="true">lbrb.github.io/2014/01/02/my-2013.html</guid>
        <pubDate>Thu, 02 Jan 2014 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;动机&lt;/h3&gt;

&lt;p&gt;不知不觉已经进入2014年，今年是我的本命年，实际上从去年到今年也是我人生轨迹变化极快的一年。昨天晚上很晚才睡，有幸读了几个关注的人的2013总结，收益颇多。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://dbanotes.net/mylife/2013_personal_review.html&quot;&gt;2013 年个人总结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tiny4.org/blog/2014/01/tinyfool-2013/&quot;&gt;Tinyfool的2013年总结————在困惑和挣扎中试图前行&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.iwangke.me/2014/01/01/three-years-in-app-store-as-indie-developer/&quot;&gt;我在App Store这三年&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是我打算自己也写一篇2013总结，未来自己回顾一年历程的时候，能感觉到自己成长了多少。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实习&lt;/h3&gt;
&lt;p&gt;2013最早的4个月一直是在研究OpenStack是什么，它的作用机制，它的应用方向以及怎么把它运行起来。着手研究OpenStack其实从2012年10月就开始了，我刚刚进入大四，保研后的研究生导师把我推荐到联想实习。&lt;/p&gt;

&lt;p&gt;OpenStack的学习对我来说真的算是一次不一样的体验，因为它足够大。从概念上如云计算，到技术层面如虚拟化，再到运维层面如自动化运维，最后到开源项目编程，每一部分的学习都让我获益颇丰。我在其中主要的研究虚拟机的监控，这个组件让我更能了解到它各个部分协调运行的机制。&lt;/p&gt;

&lt;p&gt;4月的时候由于导师需要，从联想回来给实验室弄OpenStack环境，同时我也准备就这个方向写我的毕业论文。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;毕业设计&lt;/h3&gt;
&lt;p&gt;回来以后的感觉真的是…节奏缓慢，没有项目的驱动，没有任务的督促。因为老师也不知道要拿这个东西干什么，甚至都不去看我们给他弄好的环境。为了不让自己就这样轻轻松松毕业，我打算继续研究OpenStack，至少完全搞定一个组件。&lt;/p&gt;

&lt;p&gt;当时正好在于Grizzly版本发布，OpenStack自己的监控组件Ceilometer正式发布（之前我们用新浪开源的Kanyun），对我来说正好是个千载难逢的学习机会。&lt;/p&gt;

&lt;p&gt;从4月到7月毕业，3个月的时间，我读完了Ceilometer组件的代码，顺便基于它还有Horizon搞了二次开发，顺利毕业。为了阅读代码，我感觉到自己的Python水平提升了不少，最让我满意的应该是还写了几篇有关这个组件的博客。这算是自己真正首次原创了吧。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;放弃读研&amp;amp;出国准备&lt;/h3&gt;
&lt;p&gt;从保研开始呆在研究生实验室有快1年，曾经保研只是为了让家人放心，毕业后能找个不错的工作拿到北京户口，这似乎是生活在小县城中父母眼里最好的归宿。但我感受到这里并不适合我，我不希望把自己最有干劲的几年浪费在这个地方。&lt;/p&gt;

&lt;p&gt;我没有办法改变环境，那我只能换一个环境。&lt;/p&gt;

&lt;p&gt;一个解决方式是去留学。&lt;/p&gt;

&lt;p&gt;本科能聊的来的2个哥们，一个已经去了美国，另一个在准备去美国的路上…在他们给我各种灌输之下，以及对北京兴趣的减少，我动摇了。&lt;/p&gt;

&lt;p&gt;但是我错误判断了自己的英语实力和学习速度…以为我可以像学编程语言一样学英语，但事实显然不是这样的。4个月，GRE+TOEFL几乎把我累死，另一方面还要不停地给家人做工作。最后分数是有了，但是完全达不到自己的预期。&lt;/p&gt;

&lt;p&gt;另一个解决方式是去工作。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;一个工作&lt;/h3&gt;
&lt;p&gt;眼看想去的几个学校无望，我甚至做了最坏的打算，再准备一年再出去。&lt;/p&gt;

&lt;p&gt;我完全没有想到我轨迹又变了，因为一个偶然的工作机会。&lt;/p&gt;

&lt;p&gt;英语的准备过程真的有些枯燥，我止不住想去写点东西（码农的命..）。看到V2EX上的一则低调招聘贴，澳洲公司，还能远程，这对于正在学习英语，又想编程的我是最佳选择，没多想就交了简历。&lt;/p&gt;

&lt;p&gt;电话+QQ联系之后就开始实习了，不得不说这个效率…&lt;/p&gt;

&lt;p&gt;至今为止一个半月的实习，感觉自己在这里有很大的发挥空间，也能在这个方面提升不少。如果能在年后顺利去澳洲工作，或许也是不错的选择。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;总结&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;但行好事，莫问前程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;埋头干事，抬头看路&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这两句似乎有些矛盾，不过我总拿它们来作为自己选择的标准。前者从Fenng听来，后者忘了。&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>2013阅读书单</title>
        <link>lbrb.github.io/2013/12/20/book-list-of-2013.html</link>
        <guid isPermaLink="true">lbrb.github.io/2013/12/20/book-list-of-2013.html</guid>
        <pubDate>Fri, 20 Dec 2013 00:00:00 +0800</pubDate>
        <description>
</description>
      </item>
    
      <item>
        <title>在ubuntu下搭建pptp vpn服务器</title>
        <link>lbrb.github.io/2013/12/11/deploy-pptp-vpn-in-ubuntu.html</link>
        <guid isPermaLink="true">lbrb.github.io/2013/12/11/deploy-pptp-vpn-in-ubuntu.html</guid>
        <pubDate>Wed, 11 Dec 2013 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;最近弄了digitalocean的vps，研究了一下搭建一个vpn自己用，因为有些系统代理goagent还是搞不定。但是事实证明digitalocean线路还是很不稳，基本上没啥帮助=0=&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;pptp&quot;&gt;pptp配置&lt;/h2&gt;
&lt;p&gt;### 安装pptp&lt;br /&gt;
用ubuntu就是安装东西快&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get -y update
sudo apt-get -y install pptpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;修改配置脚本&lt;/h3&gt;
&lt;p&gt;配置一下dns&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;gt;/etc/ppp/options.pptpd &amp;lt;&amp;lt;END
name pptpd
refuse-pap
refuse-chap
refuse-mschap
require-mschap-v2
require-mppe-128
ms-dns 8.8.8.8
ms-dns 8.8.4.4
proxyarp
lock
nobsdcomp 
novj
novjccomp
nologfd
END
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;name pptpd（pptpd服务名，可以随便填写。）&lt;/li&gt;
  &lt;li&gt;refuse-pap（拒绝pap身份认证模式。）&lt;/li&gt;
  &lt;li&gt;refuse-chap（拒绝chap身份认证模式。）&lt;/li&gt;
  &lt;li&gt;refuse-mschap（拒绝mschap身份认证模式。）&lt;/li&gt;
  &lt;li&gt;require-mschap-v2（在端点进行连接握手时需要使用微软的 mschap-v2 进行自身验证。）&lt;/li&gt;
  &lt;li&gt;require-mppe-128（MPPE 模块使用 128 位加密。）&lt;/li&gt;
  &lt;li&gt;ms-dns 8.8.8.8 (ppp 为 Windows 客户端提供 DNS 服务器 IP 地址。)&lt;/li&gt;
  &lt;li&gt;proxyarp (建立 ARP 代理键值。)&lt;/li&gt;
  &lt;li&gt;nodefaultroute（不替换默认路由）&lt;/li&gt;
  &lt;li&gt;debug（开启调试模式，相关信息记录在 /var/logs/message 中。）&lt;/li&gt;
  &lt;li&gt;lock（锁定客户端 PTY 设备文件。）&lt;/li&gt;
  &lt;li&gt;nobsdcomp (禁用 BSD 压缩模式。)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还有ip&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;gt;/etc/pptpd.conf &amp;lt;&amp;lt;END
option /etc/ppp/options.pptpd
logwtmp
localip 192.168.2.1
remoteip 192.168.2.10-100
END
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;增加路由转发&lt;/h2&gt;
&lt;p&gt;### ipv4转发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;gt;&amp;gt; /etc/sysctl.conf &amp;lt;&amp;lt;END
net.ipv4.ip_forward=1
END
sysctl -p
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;iptables&quot;&gt;修改iptables&lt;/h3&gt;

&lt;p&gt;备份当前iptables&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables-save &amp;gt; /etc/iptables.down.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改iptable NAT转发&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -t nat -A POSTROUTING -s 192.168.2.0/24 -o eth0 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置MTU&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -I FORWARD -s 192.168.2.0/24 -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1300
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存新iptables&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables-save &amp;gt; /etc/iptables.up.rules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启后继续有效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;gt;&amp;gt;/etc/ppp/pptpd-options&amp;lt;&amp;lt;EOF
pre-up iptables-restore &amp;lt; /etc/iptables.up.rules
post-down iptables-restore &amp;lt; /etc/iptables.down.rules
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;增加用户&lt;/h3&gt;

&lt;p&gt;增加帐号密码都是test的用户&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat &amp;gt;/etc/ppp/chap-secrets &amp;lt;&amp;lt;END
test pptpd test *
END
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;重启服务&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/etc/init.d/pptpd restart
netstat -lntp
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-4&quot;&gt;自动脚本&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;wget -c https://raw2.github.com/suyan/Scripts/master/Setup/pptp.sh
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Linux下多个命令连续执行方法</title>
        <link>lbrb.github.io/2013/12/08/linux-command-continue.html</link>
        <guid isPermaLink="true">lbrb.github.io/2013/12/08/linux-command-continue.html</guid>
        <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;有的时候执行一些简单指令的时候总不想分好几次输入，利用以下方法可以方便的一次执行多个命令&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;连续不中断执行&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;;&lt;/code&gt;可以让多个命令连续知行，中间出现错误并不会中断后面命令，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir test; mkdir test; rmdir test;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然第二条指令会报错，但是不会影响后面的指令，最后test目录不存在&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;出错停止后面指令&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;分割的命令，如果没有错误会一直执行下去，出现错误立即中止，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir test &amp;amp;&amp;amp; mkdir test &amp;amp;&amp;amp; rmdir test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这回在第二个指令处就中止了&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;一次正确即停止&lt;/h3&gt;

&lt;p&gt;用&lt;code&gt;||&lt;/code&gt;分割的命令，如果有错误就一直执行下去，直到一次正确立即中止，如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir test || mkdir test || rmdir test
mkdir test || mkdir test || rmdir test || mkdir test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次执行第一条指令就正确，后面的不执行&lt;/p&gt;

&lt;p&gt;第二次执行前两条都错误，直到最后一条才正确，最后一条不再执行&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>基于CSS3实现尖角面包屑</title>
        <link>lbrb.github.io/2013/12/08/implemention-of-breadcrumbs-by-css3.html</link>
        <guid isPermaLink="true">lbrb.github.io/2013/12/08/implemention-of-breadcrumbs-by-css3.html</guid>
        <pubDate>Sun, 08 Dec 2013 00:00:00 +0800</pubDate>
        <description>&lt;blockquote&gt;
  &lt;p&gt;尖角面包屑导航应该算是比较常见的导航之一，尤其是在做流程引导的时候。为了做一个比较好看的导航，一般都会做成尖角的，而且还会有渐变色，这就是稍微麻烦点的地方了，下面是这个导航的一个实现原理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;尖角实现&lt;/h2&gt;
&lt;p&gt;尖角的实现利用了CSS的before和after特性，以及无内容情况下border的特性，先来看看他们的介绍&lt;/p&gt;

&lt;h3 id=&quot;beforeafter&quot;&gt;伪元素before和after&lt;/h3&gt;
&lt;p&gt;before和after分别在一个元素前和后添加内容，使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a:before, a:after {
    content: &quot;123&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段的意思就是在a标签前后都增加了123文本，利用这个特性，可以给一个按钮前后都增加尖角了。&lt;/p&gt;

&lt;h3 id=&quot;border&quot;&gt;利用border实现尖角&lt;/h3&gt;
&lt;p&gt;border有一个特点，就是当元素内容是空的时候，border会占据内容的空间，效果点&lt;a href=&quot;http://codepen.io/suyan0830/pen/roAtK&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;HTML代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;bor&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.bor{
  width:0px;
  height:0px;
  border: solid;
  border-width: 20px 20px 20px 20px;
  border-color: red yellow green black; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那么只要让before和after都变成这个样子，利用位置定位将这两部分分别移到相应位置，然后调整border某一边是透明就好了。&lt;/p&gt;

&lt;h3 id=&quot;border-1&quot;&gt;调整border透明&lt;/h3&gt;
&lt;p&gt;如果导航是纯色的，那么直接将before和after作为尖角即可，因为border可以设置纯色。但是如果想要给导航设置颜色渐变，那就只能通过设置导航来实现，border不能设置渐变色。这个时候只能通过将border设置的和背景色一致，遮挡导航主体部分来实现尖角特点。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;效果点&lt;a href=&quot;http://codepen.io/suyan0830/pen/uqHCD&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;

&lt;p&gt;HTML代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;breadcrumbs&quot;&amp;gt;
  &amp;lt;div class=&quot;bread current&quot;&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;test&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;div class=&quot;bread&quot;&amp;gt;&amp;lt;a href=&quot;&quot;&amp;gt;test2&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CSS代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;body{
  background:#D7D7D7;
}
.breadcrumbs{
  padding-left:40px;
  padding-top:7px;
}
.bread,.bread:hover{
  font-size:14px;
  display:inline;
  float:left;
  width:200px;
  background-color: #ddd;
  padding: 4px 10px 2px 0px;
  margin-right:40px;
  position: relative;
}
.bread{
  background-image: linear-gradient(to top, #F0F0F0, #F2F2F2);
}
.bread:hover{
  background-image: linear-gradient(to top, #EBE470, #F3F3EF); 
}
.current{
  background-image: linear-gradient(to top, #EBE470, #F3F3EF);
}
.bread &amp;gt; a{
  text-decoration: none;
  padding: 10px 10px 10px 40px;
}
.bread:hover &amp;gt; a{
  text-decoration: none;
  padding: 10px 10px 10px 40px;
}
.bread:before,.bread:after{
  content:&quot;&quot;;
  border:solid;
  position: absolute;
  top:0px;
  border-width: 13px;
}
.bread:before{
  left:0px;
  border-color: transparent transparent transparent #D7D7D7;
}
.bread:after{
  right:0px;
  border-color: #D7D7D7 #D7D7D7 #D7D7D7 transparent;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
  </channel>
</rss>